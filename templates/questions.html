<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Das Orakel von M√§gdesprung - Fragebogen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      overflow-x: hidden;
      color: #ffffff;
    }

    .onboarding-container {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 2rem;
      position: relative;
    }

    /* Background animation */
    .floating-bubbles {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
    }

    .bubble {
      position: absolute;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      animation: float 6s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0px) rotate(0deg); }
      50% { transform: translateY(-20px) rotate(180deg); }
    }

    /* Language toggle */
    .lang-toggle {
      position: fixed;
      top: 2rem;
      right: 2rem;
      z-index: 1000;
      background: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 25px;
      padding: 0.75rem 1.5rem;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 600;
      color: white;
    }

    .lang-toggle:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-2px);
    }

    .lang-menu {
      position: absolute;
      top: 60px;
      right: 0;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(15px);
      border-radius: 15px;
      overflow: hidden;
      display: none;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .lang-menu button {
      border: none;
      background: none;
      padding: 1rem 1.5rem;
      width: 100%;
      text-align: left;
      cursor: pointer;
      color: #333;
      font-weight: 500;
      transition: background 0.2s ease;
    }

    .lang-menu button:hover {
      background: rgba(102, 126, 234, 0.1);
    }

    /* Progress indicator */
    .progress-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 4px;
      background: rgba(255, 255, 255, 0.2);
      z-index: 999;
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #00f5ff, #0099ff);
      transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      width: 0%;
    }

    /* Question content */
    .question-container {
      max-width: 800px;
      width: 100%;
      text-align: center;
      animation: slideInUp 0.6s ease-out;
    }

    @keyframes slideInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .question-number {
      font-size: 1rem;
      font-weight: 600;
      opacity: 0.8;
      margin-bottom: 1rem;
      letter-spacing: 0.5px;
    }

    .question-text {
      font-size: 2.5rem;
      font-weight: 700;
      line-height: 1.2;
      margin-bottom: 3rem;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    @media (max-width: 768px) {
      .question-text {
        font-size: 1.8rem;
        margin-bottom: 2rem;
      }
    }

    /* Answer bubbles */
    .answers-grid {
      display: grid;
      gap: 1rem;
      margin-bottom: 3rem;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }

    .answer-bubble {
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      padding: 1.5rem 2rem;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-size: 1.1rem;
      font-weight: 500;
      color: white;
      position: relative;
      overflow: hidden;
    }

    .answer-bubble::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      transition: left 0.5s;
    }

    .answer-bubble:hover::before {
      left: 100%;
    }

    .answer-bubble:hover {
      background: rgba(255, 255, 255, 0.25);
      border-color: rgba(255, 255, 255, 0.4);
      transform: translateY(-3px);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }

    .answer-bubble.selected {
      background: rgba(255, 255, 255, 0.9);
      color: #333;
      border-color: #00f5ff;
      box-shadow: 0 0 0 3px rgba(0, 245, 255, 0.3);
    }

    .answer-bubble.other-option {
      background: rgba(255, 255, 255, 0.1);
      border: 2px dashed rgba(255, 255, 255, 0.4);
    }

    /* Text input for "other" */
    .other-input {
      width: 100%;
      background: rgba(255, 255, 255, 0.9);
      border: none;
      border-radius: 15px;
      padding: 1.5rem;
      font-size: 1.1rem;
      color: #333;
      margin-top: 1rem;
      transition: all 0.3s ease;
      display: none;
    }

    .other-input:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 245, 255, 0.3);
    }

    .other-input::placeholder {
      color: #666;
    }

    /* Navigation */
    .nav-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      max-width: 600px;
      margin-top: 2rem;
    }

    .nav-btn {
      background: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 50px;
      padding: 1rem 2rem;
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1rem;
    }

    .nav-btn:hover:not(:disabled) {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
    }

    .nav-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .nav-btn.primary {
      background: linear-gradient(135deg, #00f5ff, #0099ff);
      border: none;
    }

    .nav-btn.primary:hover:not(:disabled) {
      background: linear-gradient(135deg, #00d4ff, #0077ff);
    }

    /* Progress dots */
    .progress-dots {
      display: flex;
      justify-content: center;
      gap: 0.5rem;
      margin-top: 2rem;
    }

    .progress-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.3);
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .progress-dot.active {
      background: #00f5ff;
      transform: scale(1.2);
    }

    .progress-dot.completed {
      background: #00ff88;
    }

    /* Toast notifications */
    .toast {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 1rem 2rem;
      border-radius: 25px;
      font-weight: 500;
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 1000;
      backdrop-filter: blur(10px);
    }

    .toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    /* Loading state */
    .loading {
      pointer-events: none;
    }

    .loading .question-container {
      opacity: 0.6;
    }

    /* Welcome screen */
    .welcome-screen {
      text-align: center;
      animation: fadeIn 1s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1); }
    }

    .welcome-title {
      font-size: 3rem;
      font-weight: 800;
      margin-bottom: 1rem;
      background: linear-gradient(135deg, #fff, #00f5ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .welcome-subtitle {
      font-size: 1.3rem;
      opacity: 0.9;
      margin-bottom: 3rem;
      font-weight: 400;
    }

    .start-btn {
      background: linear-gradient(135deg, #00f5ff, #0099ff);
      border: none;
      border-radius: 50px;
      padding: 1.5rem 3rem;
      color: white;
      font-size: 1.2rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 8px 30px rgba(0, 245, 255, 0.3);
    }

    .start-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 12px 35px rgba(0, 245, 255, 0.4);
    }
  </style>
  
</head>


<body>

  <!-- Floating background bubbles -->
  <div class="floating-bubbles" id="floating-bubbles"></div>

  <!-- Progress bar -->
  <div class="progress-container">
    <div class="progress-bar" id="progress-bar"></div>
  </div>

  <!-- Language toggle -->
  <div class="lang-toggle" id="lang-toggle">
    <span id="lang-flag">üá©üá™</span> <span id="lang-label">Deutsch</span> ‚ñº
    <div class="lang-menu" id="lang-menu">
      <button data-lang="de">üá©üá™ Deutsch</button>
      <button data-lang="en">üá¨üáß English</button>
    </div>
  </div>

  <!-- Main container -->
  <div class="onboarding-container" id="onboarding-container">
    <!-- Welcome screen -->
    <div class="welcome-screen" id="welcome-screen">
      <h1 class="welcome-title" id="welcome-title">Das Orakel von M√§gdesprung</h1>
      <p class="welcome-subtitle" id="welcome-subtitle">Entdecke deine innere Weisheit durch personalisierte Fragen</p>
      <button class="start-btn" id="start-btn">Beginnen</button>
    </div>

    <!-- Question screen -->
    <div class="question-container" id="question-container" style="display: none;">
      <div class="question-number" id="question-number">Frage 1 von 7</div>
      <h2 class="question-text" id="question-text"></h2>
      
      <div class="answers-grid" id="answers-grid"></div>
      
      <textarea class="other-input" id="other-input" placeholder="Deine Antwort hier..."></textarea>
      
      <div class="nav-container">
        <button class="nav-btn" id="prev-btn" disabled>‚Üê Zur√ºck</button>
        <div class="progress-dots" id="progress-dots"></div>
        <button class="nav-btn primary" id="next-btn">Weiter ‚Üí</button>
      </div>
    </div>
  </div>

  <!-- Toast notification -->
  <div class="toast" id="toast"></div>

  <script>
    
    // Translations (same as before)
    const translations = {
      de: {
        welcome: "Das Orakel von M√§gdesprung",
        welcomeSubtitle: "Entdecke deine innere Weisheit durch personalisierte Fragen",
        start: "Beginnen",
        next: "Weiter ‚Üí",
        prev: "‚Üê Zur√ºck",
        finish: "Abschlie√üen ‚Üí",
        otherPlaceholder: "Deine Antwort hier...",
        questionProgress: "Frage {current} von {total}",
        answersSaved: "Antworten gespeichert. Vielen Dank!",
        errorSave: "Fehler beim Speichern. Bitte versuche es erneut.",
        selectAnswer: "Bitte w√§hle eine Antwort aus.",
        langGerman: "Deutsch",
        langEnglish: "English",
        skip: "√úberspringen",
        skipAllConfirm: "M√∂chtest du alle Fragen √ºberspringen?"
      },
      en: {
        welcome: "The Oracle of M√§gdesprung",
        welcomeSubtitle: "Discover your inner wisdom through personalized questions",
        start: "Begin",
        next: "Next ‚Üí",
        prev: "‚Üê Back",
        finish: "Finish ‚Üí",
        otherPlaceholder: "Your answer here...",
        questionProgress: "Question {current} of {total}",
        answersSaved: "Answers saved. Thank you!",
        errorSave: "Error saving. Please try again.",
        selectAnswer: "Please select an answer.",
        langGerman: "German",
        langEnglish: "English",
        skip: "Skip",
        skipAllConfirm: "Do you want to skip all questions?"
      }
    };
// State management
let currentLang = localStorage.getItem('userLang') || (navigator.language.startsWith('en') ? 'en' : 'de');
let currentQuestion = 0;
let userAnswers = {};
let showingWelcome = true;
let questions = [];

// DOM elements
const elements = {
  langToggle: document.getElementById('lang-toggle'),
  langMenu: document.getElementById('lang-menu'),
  langFlag: document.getElementById('lang-flag'),
  langLabel: document.getElementById('lang-label'),
  welcomeScreen: document.getElementById('welcome-screen'),
  questionContainer: document.getElementById('question-container'),
  welcomeTitle: document.getElementById('welcome-title'),
  welcomeSubtitle: document.getElementById('welcome-subtitle'),
  startBtn: document.getElementById('start-btn'),
  questionNumber: document.getElementById('question-number'),
  questionText: document.getElementById('question-text'),
  answersGrid: document.getElementById('answers-grid'),
  otherInput: document.getElementById('other-input'),
  prevBtn: document.getElementById('prev-btn'),
  nextBtn: document.getElementById('next-btn'),
  progressDots: document.getElementById('progress-dots'),
  progressBar: document.getElementById('progress-bar'),
  toast: document.getElementById('toast')
};

// Helper functions
function t(key, params = {}) {
  let text = translations[currentLang][key] || key;
  Object.entries(params).forEach(([k, v]) => {
    text = text.replace(`{${k}}`, v);
  });
  return text;
}

function showToast(message) {
  elements.toast.textContent = message;
  elements.toast.classList.add('show');
  setTimeout(() => {
    elements.toast.classList.remove('show');
  }, 3000);
}

function updateLanguage() {
  elements.langFlag.textContent = currentLang === 'de' ? 'üá©üá™' : 'üá¨üáß';
  elements.langLabel.textContent = t(currentLang === 'de' ? 'langGerman' : 'langEnglish');
  
  if (showingWelcome) {
    elements.welcomeTitle.textContent = t('welcome');
    elements.welcomeSubtitle.textContent = t('welcomeSubtitle');
    elements.startBtn.textContent = t('start');
  } else {
    renderQuestion();
  }
}

function createFloatingBubbles() {
  const container = document.getElementById('floating-bubbles');
  for (let i = 0; i < 15; i++) {
    const bubble = document.createElement('div');
    bubble.className = 'bubble';
    bubble.style.left = Math.random() * 100 + '%';
    bubble.style.top = Math.random() * 100 + '%';
    bubble.style.width = bubble.style.height = Math.random() * 60 + 20 + 'px';
    bubble.style.animationDelay = Math.random() * 6 + 's';
    bubble.style.animationDuration = Math.random() * 4 + 4 + 's';
    container.appendChild(bubble);
  }
}

function renderProgressDots() {
  elements.progressDots.innerHTML = '';
  questions.forEach((_, index) => {
    const dot = document.createElement('div');
    dot.className = 'progress-dot';
    if (index < currentQuestion) {
      dot.classList.add('completed');
    } else if (index === currentQuestion) {
      dot.classList.add('active');
    }
    dot.addEventListener('click', () => {
      if (index < currentQuestion) {
        currentQuestion = index;
        renderQuestion();
      }
    });
    elements.progressDots.appendChild(dot);
  });
}

function updateProgressBar() {
  const progress = ((currentQuestion + 1) / questions.length) * 100;
  elements.progressBar.style.width = progress + '%';
}

function renderQuestion() {
  const question = questions[currentQuestion];
  
  elements.questionNumber.textContent = t('questionProgress', {
    current: currentQuestion + 1,
    total: questions.length
  });
  
  elements.questionText.textContent = question.text[currentLang];
  
  // Clear previous answers
  elements.answersGrid.innerHTML = '';
  elements.otherInput.style.display = 'none';
  elements.otherInput.value = '';
  
  // Render answer bubbles
  question.answers[currentLang].forEach((answer, index) => {
    const bubble = document.createElement('div');
    bubble.className = 'answer-bubble';
    bubble.textContent = answer;
    
    bubble.addEventListener('click', () => {
      // Clear all selections
      document.querySelectorAll('.answer-bubble').forEach(b => b.classList.remove('selected'));
      
      // Select this bubble
      bubble.classList.add('selected');
      
      // Store answer
      userAnswers[question.id] = {
        index: index,
        text: answer,
        isOther: false
      };
      
      // Hide other input (since this is a normal option)
      elements.otherInput.style.display = 'none';
      elements.otherInput.value = '';
      
      elements.nextBtn.disabled = false;
    });
    
    elements.answersGrid.appendChild(bubble);
  });

  // If other === true, add an "Other" option bubble
  if (question.other) {
    const otherBubble = document.createElement('div');
    otherBubble.className = 'answer-bubble other-option';
    otherBubble.textContent = currentLang === 'de' ? 'Andere' : 'Other';
    otherBubble.addEventListener('click', () => {
      document.querySelectorAll('.answer-bubble').forEach(b => b.classList.remove('selected'));
      otherBubble.classList.add('selected');
      
      userAnswers[question.id] = {
        index: question.answers[currentLang].length, // index after last answer
        text: otherBubble.textContent,
        isOther: true,
        otherText: elements.otherInput.value.trim()
      };
      
      elements.otherInput.style.display = 'block';
      elements.otherInput.placeholder = t('otherPlaceholder');
      elements.otherInput.focus();
      
      elements.nextBtn.disabled = false;
    });
    elements.answersGrid.appendChild(otherBubble);
  }
  
  // Restore previous selection
  if (userAnswers[question.id]) {
    const bubbles = document.querySelectorAll('.answer-bubble');
    const answerData = userAnswers[question.id];
    if (bubbles[answerData.index]) {
      bubbles[answerData.index].classList.add('selected');
      if (answerData.isOther) {
        elements.otherInput.style.display = 'block';
        elements.otherInput.value = answerData.otherText || '';
        elements.otherInput.placeholder = t('otherPlaceholder');
      }
      elements.nextBtn.disabled = false;
    }
  } else {
    // If no previous answer, disable next
    elements.nextBtn.disabled = true;
  }
  
  // Update navigation
  elements.prevBtn.disabled = currentQuestion === 0;
  elements.nextBtn.textContent = currentQuestion === questions.length - 1 ? t('finish') : t('next');

  // Add Skip button if not first question
  let skipBtn = document.getElementById('skip-btn');
  if (!skipBtn) {
    skipBtn = document.createElement('button');
    skipBtn.id = 'skip-btn';
    skipBtn.className = 'nav-btn skip-btn';
    skipBtn.textContent = currentLang === 'de' ? '√úberspringen' : 'Skip';
    skipBtn.style.marginRight = '10px';
    elements.nextBtn.parentNode.insertBefore(skipBtn, elements.nextBtn);
    
    skipBtn.addEventListener('click', () => {
      userAnswers[question.id] = {
        index: -1,
        text: 'skipped',
        isOther: false
      };
      // Enable next to continue
      elements.nextBtn.disabled = false;
      // Move to next question or submit if last
      if (currentQuestion === questions.length - 1) {
        submitAnswers();
      } else {
        currentQuestion++;
        renderQuestion();
      }
    });
  }
  
  // Hide skip button for first question (consent)
  if (currentQuestion === 0) {
    skipBtn.style.display = 'none';
  } else {
    skipBtn.style.display = 'inline-block';
  }

  renderProgressDots();
  updateProgressBar();
}

function startQuestionnaire() {
  showingWelcome = false;
  elements.welcomeScreen.style.display = 'none';
  elements.questionContainer.style.display = 'block';
  renderQuestion();
}

async function submitAnswers() {
  try {
    elements.nextBtn.disabled = true;
    elements.nextBtn.textContent = currentLang === 'de' ? 'Speichern...' : 'Saving...';

    // Save other input if visible
    if (elements.otherInput.style.display === 'block') {
      const currentQ = questions[currentQuestion];
      if (userAnswers[currentQ.id]) {
        userAnswers[currentQ.id].otherText = elements.otherInput.value.trim();
      }
    }

    // If user answered NO to first question (consent), mark all as skipped
    if (questions[0].id === 'consent_to_answer' && userAnswers['consent_to_answer']) {
      const consentAnswer = userAnswers['consent_to_answer'].text.toLowerCase();
      if (consentAnswer === 'no' || consentAnswer === 'nein') {
        questions.forEach(q => {
          userAnswers[q.id] = {
            index: -1,
            text: 'skipped',
            isOther: false
          };
        });
      }
    }

    const formattedAnswers = questions.map(q => {
      const answerData = userAnswers[q.id];
      if (!answerData) return `question: ${q.text[currentLang]} answer: (no response)`;

      const answerText = answerData.isOther && answerData.otherText
        ? answerData.otherText
        : answerData.text;

      return `question: ${q.text[currentLang]} answer: ${answerText}`;
    });

    console.log('Submitting answers:', formattedAnswers);
    console.log('Current language:', currentLang);
    
    const payload = {
      answers: formattedAnswers,
      language: currentLang,
    };

    const response = await fetch('/save-answers', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload)
    });

    const result = await response.json();
    console.log('Response from server:', result);

    if (response.ok) {
      if (result.status === 'saved'){
        console.log('Saved:', result);
        window.location.href = '/chat'; // Redirect to chat page
      } else {
        console.error('Error saving:', result.error || 'Unknown error');
        showToast(t('errorSave'));
        elements.nextBtn.disabled = false;
        elements.nextBtn.textContent = t('finish');
        return;
      }
    } else {
      console.error('Error saving:', result.error || 'Unknown error');
      showToast(t('errorSave'));
      elements.nextBtn.disabled = false;
      elements.nextBtn.textContent = t('finish');
    }
    
  } catch (error) {
    console.error('Error saving answers:', error);
    showToast(t('errorSave'));
    elements.nextBtn.disabled = false;
    elements.nextBtn.textContent = t('finish');
  }
}

// Event listeners
elements.langToggle.addEventListener('click', () => {
  const isOpen = elements.langMenu.style.display === 'block';
  elements.langMenu.style.display = isOpen ? 'none' : 'block';
});

elements.langMenu.addEventListener('click', (e) => {
  if (e.target.dataset.lang) {
    currentLang = e.target.dataset.lang;
    localStorage.setItem('userLang', currentLang);
    elements.langMenu.style.display = 'none';
    updateLanguage();
  }
});

elements.startBtn.addEventListener('click', startQuestionnaire);

elements.prevBtn.addEventListener('click', () => {
  if (currentQuestion > 0) {
    currentQuestion--;
    renderQuestion();
  }
});

elements.nextBtn.addEventListener('click', () => {
  const currentQ = questions[currentQuestion];
  if (!userAnswers[currentQ.id]) {
    showToast(t('selectAnswer'));
    return;
  }

  // Save other input if visible
  if (elements.otherInput.style.display === 'block') {
    userAnswers[currentQ.id].otherText = elements.otherInput.value.trim();
  }

  // Check if current question has skipAll flag and answer is "No"
  if (
    currentQ.skipAll &&
    (userAnswers[currentQ.id].text.toLowerCase() === 'no' ||
     userAnswers[currentQ.id].text.toLowerCase() === 'nein')
  ) {
    // Mark all questions as skipped
    questions.forEach(q => {
      userAnswers[q.id] = {
        index: -1,
        text: 'skipped',
        isOther: false
      };
    });
    // Submit immediately
    submitAnswers();
    return;
  }

  // Normal flow: next question or submit if last
  if (currentQuestion === questions.length - 1) {
    submitAnswers();
  } else {
    currentQuestion++;
    renderQuestion();
  }
});


elements.otherInput.addEventListener('input', () => {
  const currentQ = questions[currentQuestion];
  if (userAnswers[currentQ.id]) {
    userAnswers[currentQ.id].otherText = elements.otherInput.value.trim();
  }
});

// Close language menu when clicking outside
document.addEventListener('click', (e) => {
  if (!elements.langToggle.contains(e.target)) {
    elements.langMenu.style.display = 'none';
  }
});

// Initialize bubbles and update language only AFTER fetching questions:
function initializeApp() {
  createFloatingBubbles();
  updateLanguage();
}

fetch('./questions.json')
  .then(response => {
    if (!response.ok) throw new Error('Network response was not ok');
    return response.json();
  })
  .then(data => {
    questions = data;
    initializeApp();
  })
  .catch(error => {
    console.error('There was a problem fetching questions:', error);
    showToast('Error loading questions.');
  });

  </script>
</body>
</html>